[{"filePath":"C:\\Users\\shingo_kosaka.ARGOGRAPHICS\\Desktop\\GlobalMacroSignal\\frontend\\app\\api\\test-gateway\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_request' is defined but never used.","line":7,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":35},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1077,1080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1077,1080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { generateText } from 'ai';\r\nimport { gateway } from '@ai-sdk/gateway';\r\n\r\nexport const dynamic = 'force-dynamic';\r\n\r\nexport async function GET(_request: NextRequest) {\r\n    const API_KEY = process.env.AI_GATEWAY_API_KEY;\r\n\r\n    if (!API_KEY) {\r\n        return NextResponse.json({ status: \"ERROR\", message: \"Env missing (AI_GATEWAY_API_KEY)\" });\r\n    }\r\n\r\n    // Based on User's Model List: naming uses '/' and gemini-2.0-flash is available.\r\n    const modelsToProbe = [\r\n        'google/gemini-2.0-flash',\r\n        'google/gemini-1.5-flash',\r\n        'google:gemini-2.0-flash',\r\n        'google:gemini-1.5-flash'\r\n    ];\r\n\r\n    const results: { id: string; status: string; text?: string; error?: string }[] = [];\r\n\r\n    for (const m of modelsToProbe) {\r\n        try {\r\n            // We use the gateway helper. If passing a string with '/', \r\n            // the SDK might interpret it differently, so we try it.\r\n            const { text } = await generateText({\r\n                model: gateway(m as string) as any, // gateway helper still needs casting if m is string\r\n                prompt: \"Say 'GATEWAY_SUCCESS'\",\r\n            });\r\n            results.push({ id: m, status: \"SUCCESS\", text });\r\n\r\n            // If one succeeds, we can stop or just collect all\r\n            if (text) {\r\n                return NextResponse.json({\r\n                    status: \"SUCCESS_IDENTIFIED\",\r\n                    winner: m,\r\n                    text: text\r\n                });\r\n            }\r\n        } catch (e: unknown) {\r\n            results.push({ id: m, status: \"FAILURE\", error: (e as Error).message || \"404\" });\r\n        }\r\n    }\r\n\r\n    return NextResponse.json({\r\n        status: \"PROBE_V3_COMPLETE\",\r\n        results: results\r\n    });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\shingo_kosaka.ARGOGRAPHICS\\Desktop\\GlobalMacroSignal\\frontend\\app\\technical\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\shingo_kosaka.ARGOGRAPHICS\\Desktop\\GlobalMacroSignal\\frontend\\components\\DynamicStructuredData.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\shingo_kosaka.ARGOGRAPHICS\\Desktop\\GlobalMacroSignal\\frontend\\components\\LiveWikiData.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\shingo_kosaka.ARGOGRAPHICS\\Desktop\\GlobalMacroSignal\\frontend\\components\\TerminalPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\shingo_kosaka.ARGOGRAPHICS\\Desktop\\GlobalMacroSignal\\frontend\\data\\seo.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'style' is assigned a value but never used.","line":22,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Metadata } from 'next';\r\n\r\nexport const LANGUAGES: Record<string, string> = {\r\n    'EN': 'en',\r\n    'JP': 'ja',\r\n    'CN': 'zh-CN',\r\n    'ES': 'es',\r\n    'HI': 'hi',\r\n    'ID': 'id',\r\n    'AR': 'ar',\r\n};\r\n\r\nexport const BASE_URL = 'https://www.omnimetric.net';\r\n\r\nexport type MetadataStyle = 'query' | 'path';\r\n\r\nexport function getMultilingualMetadata(\r\n    path: string,\r\n    currentLang: string,\r\n    title?: string,\r\n    description?: string,\r\n    style: MetadataStyle = 'query'\r\n): Metadata {\r\n    const langCode = currentLang.toUpperCase();\r\n    // Normalize path to not have leading slash if style is path to avoid double slashes later if needed, \r\n    // but usually path is like \"/wiki/slug\".\r\n    const cleanPath = path.startsWith('/') ? path : `/${path}`;\r\n\r\n    const alternates: Record<string, string> = {};\r\n\r\n    // Generate all 7 languages\r\n    // Generate all 7 languages (Path-based strict)\r\n    Object.entries(LANGUAGES).forEach(([code, hreflang]) => {\r\n        if (cleanPath === '/') {\r\n            // Root special case (Homepage)\r\n            alternates[hreflang] = code === 'EN'\r\n                ? `${BASE_URL}/`\r\n                : `${BASE_URL}/${code.toLowerCase()}`;\r\n        } else {\r\n            // Standard Paths (/wiki, /forex, etc)\r\n            alternates[hreflang] = `${BASE_URL}/${code.toLowerCase()}${cleanPath}`;\r\n        }\r\n    });\r\n\r\n    // Set x-default (English Path is default)\r\n    if (cleanPath === '/') {\r\n        alternates['x-default'] = `${BASE_URL}/`;\r\n    } else {\r\n        alternates['x-default'] = `${BASE_URL}/en${cleanPath}`;\r\n    }\r\n\r\n    // Canonical (Self-referencing path)\r\n    let canonical = `${BASE_URL}/${langCode.toLowerCase()}${cleanPath}`;\r\n\r\n    // Special Case: English Homepage is Root\r\n    if (langCode === 'EN' && cleanPath === '/') {\r\n        canonical = `${BASE_URL}/`;\r\n    }\r\n\r\n\r\n    return {\r\n        title: title || \"Global Macro Signal | Institutional Market Intelligence\",\r\n        description: description || \"Real-time global market risk analysis. AI-driven insights for professional investors.\",\r\n        alternates: {\r\n            canonical,\r\n            languages: Object.keys(LANGUAGES).reduce((acc: Record<string, string>, l: string) => {\r\n                const hreflang = LANGUAGES[l];\r\n                if (cleanPath === '/') {\r\n                    acc[hreflang] = l === 'EN' ? `${BASE_URL}/` : `${BASE_URL}/${l.toLowerCase()}`;\r\n                } else {\r\n                    acc[hreflang] = `${BASE_URL}/${l.toLowerCase()}${cleanPath}`;\r\n                }\r\n                return acc;\r\n            }, {} as Record<string, string>),\r\n        },\r\n    };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\shingo_kosaka.ARGOGRAPHICS\\Desktop\\GlobalMacroSignal\\frontend\\hooks\\useCurrentLang.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_searchParams' is assigned a value but never used.","line":7,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_params' is assigned a value but never used.","line":8,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_pathname' is assigned a value but never used.","line":9,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useSearchParams, useParams, usePathname } from 'next/navigation';\r\nimport { LangType, DICTIONARY } from '@/data/dictionary';\r\n\r\nexport const useCurrentLang = (): LangType => {\r\n    const _searchParams = useSearchParams();\r\n    const _params = useParams();\r\n    const _pathname = usePathname();\r\n\r\n    // 1. Priority: Search Param (?lang=JP)\r\n    const queryLang = searchParams?.get('lang');\r\n    if (queryLang && isValidLang(queryLang)) {\r\n        return queryLang.toUpperCase() as LangType;\r\n    }\r\n\r\n    // 2. Priority: Route Param (/[lang]/...)\r\n    if (params?.lang && isValidLang(params.lang as string)) {\r\n        return (params.lang as string).toUpperCase() as LangType;\r\n    }\r\n\r\n    // 3. Fallback: Parse from Pathname string purely (e.g. /jp/wiki)\r\n    // This is useful if useParams is empty in some contexts or layout nesting issues\r\n    const pathSegment = pathname?.split('/')[1];\r\n    if (pathSegment && isValidLang(pathSegment)) {\r\n        return pathSegment.toUpperCase() as LangType;\r\n    }\r\n\r\n    // 4. Default\r\n    return 'EN';\r\n};\r\n\r\nfunction isValidLang(lang: string): boolean {\r\n    return Object.keys(DICTIONARY).includes(lang.toUpperCase());\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\shingo_kosaka.ARGOGRAPHICS\\Desktop\\GlobalMacroSignal\\frontend\\lib\\wiki.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":222,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9318,9321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9318,9321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LangType } from '@/data/dictionary';\r\n// Server-side imports for Heavy Data\r\nimport fs from 'fs';\r\nimport path from 'path';\r\n\r\n// Import all data (Standard Light Data)\r\nimport glossaryEn from '@/data/glossary-en.json';\r\nimport glossaryJa from '@/data/glossary-ja.json';\r\nimport glossaryCn from '@/data/glossary-cn.json';\r\nimport glossaryEs from '@/data/glossary-es.json';\r\nimport glossaryHi from '@/data/glossary-hi.json';\r\nimport glossaryId from '@/data/glossary-id.json';\r\nimport glossaryAr from '@/data/glossary-ar.json';\r\nimport glossaryFr from '@/data/glossary-fr.json';\r\nimport glossaryDe from '@/data/glossary-de.json';\r\n\r\nimport technicalEn from '@/data/technical-en.json';\r\nimport technicalJa from '@/data/technical-ja.json';\r\nimport technicalCn from '@/data/technical-cn.json';\r\nimport technicalEs from '@/data/technical-es.json';\r\nimport technicalHi from '@/data/technical-hi.json';\r\nimport technicalId from '@/data/technical-id.json';\r\nimport technicalAr from '@/data/technical-ar.json';\r\nimport technicalFr from '@/data/technical-fr.json';\r\nimport technicalDe from '@/data/technical-de.json';\r\n\r\nimport maximsEn from '@/data/maxims-en.json';\r\nimport maximsJa from '@/data/maxims-ja.json';\r\nimport maximsCn from '@/data/maxims-cn.json';\r\nimport maximsEs from '@/data/maxims-es.json';\r\nimport maximsHi from '@/data/maxims-hi.json';\r\nimport maximsId from '@/data/maxims-id.json';\r\nimport maximsAr from '@/data/maxims-ar.json';\r\nimport maximsFr from '@/data/maxims-fr.json';\r\nimport maximsDe from '@/data/maxims-de.json';\r\n\r\n// Types\r\ntype WikiType = 'glossary' | 'technical' | 'maxim' | 'indicator' | 'asset';\r\n\r\nexport interface WikiItem {\r\n    slug: string;\r\n    type: WikiType;\r\n    category: string;\r\n    title: string;\r\n    tags: string[];\r\n    data: unknown; // Light data\r\n    heavy?: {\r\n        summary: string;\r\n        deep_dive: string;\r\n        council_debate: {\r\n            geopolitics: string;\r\n            macro: string;\r\n            quant: string;\r\n            technical: string;\r\n            policy: string;\r\n            tech: string;\r\n        };\r\n        forecast_risks: string;\r\n        gms_conclusion: string;\r\n        generated_at: string;\r\n    };\r\n}\r\n\r\nconst glossaryMap: Record<LangType, unknown[]> = { EN: glossaryEn, JP: glossaryJa, CN: glossaryCn, ES: glossaryEs, HI: glossaryHi, ID: glossaryId, AR: glossaryAr, FR: glossaryFr, DE: glossaryDe };\r\nconst technicalMap: Record<LangType, unknown[]> = { EN: technicalEn, JP: technicalJa, CN: technicalCn, ES: technicalEs, HI: technicalHi, ID: technicalId, AR: technicalAr, FR: technicalFr, DE: technicalDe };\r\nconst maximsMap: Record<LangType, unknown[]> = { EN: maximsEn, JP: maximsJa, CN: maximsCn, ES: maximsEs, HI: maximsHi, ID: maximsId, AR: maximsAr, FR: maximsFr, DE: maximsDe };\r\n\r\n// Utility to slugify string\r\nexport const slugify = (text: string) => {\r\n    return text.toString().toLowerCase()\r\n        .replace(/\\//g, '-')            // Replace slash with -\r\n        .replace(/\\s+/g, '-')           // Replace spaces with -\r\n        .replace(/[^\\w\\-]+/g, '')       // Remove all non-word chars\r\n        .replace(/\\-\\-+/g, '-')         // Replace multiple - with single -\r\n        .replace(/^-+/, '')             // Trim - from start\r\n        .replace(/-+$/, '');            // Trim - from end\r\n};\r\n\r\n// Helper: Try Load Heavy Data\r\nconst loadHeavyData = (slug: string, lang: LangType) => {\r\n    try {\r\n        // Look in frontend/data/wiki_heavy\r\n        const filePath = path.join(process.cwd(), 'data', 'wiki_heavy', `${slug}-${lang.toLowerCase()}.json`);\r\n        if (fs.existsSync(filePath)) {\r\n            const raw = fs.readFileSync(filePath, 'utf-8');\r\n            const heavy = JSON.parse(raw);\r\n\r\n            // Parse council_debate if stringified\r\n            if (heavy.sections && heavy.sections.council_debate && typeof heavy.sections.council_debate === 'string') {\r\n                try {\r\n                    heavy.sections.council_debate = JSON.parse(heavy.sections.council_debate);\r\n                } catch { }\r\n            }\r\n\r\n            return {\r\n                summary: heavy.sections?.summary || \"\",\r\n                deep_dive: heavy.sections?.deep_dive || \"\",\r\n                council_debate: heavy.sections?.council_debate || {},\r\n                forecast_risks: heavy.sections?.forecast_risks || \"\",\r\n                gms_conclusion: heavy.sections?.gms_conclusion || \"\",\r\n                generated_at: heavy.generated_at\r\n            };\r\n        }\r\n    } catch {\r\n        // Fail silent, return undefined (Hybrid Fallback)\r\n    }\r\n    return undefined;\r\n};\r\n\r\n// Helper: Scan for Heavy-Only Items (Standalone Heavy Files)\r\nconst getHeavyOnlyItems = (lang: LangType): WikiItem[] => {\r\n    const heavyDir = path.join(process.cwd(), 'data', 'wiki_heavy');\r\n    if (!fs.existsSync(heavyDir)) return [];\r\n\r\n    const files = fs.readdirSync(heavyDir);\r\n    const heavyItems: WikiItem[] = [];\r\n    const suffix = `-${lang.toLowerCase()}.json`;\r\n\r\n    files.forEach(file => {\r\n        if (file.endsWith(suffix)) {\r\n            const slug = file.replace(suffix, '');\r\n            // Load the file\r\n            const heavyData = loadHeavyData(slug, lang);\r\n\r\n            // Reconstruct a WikiItem from the heavy data\r\n            // Note: Heavy data might duplicate fields like title/category, use them.\r\n            if (heavyData) {\r\n                // Read the file raw correctly to get title/cat/type if stored there\r\n                try {\r\n                    const rawPath = path.join(heavyDir, file);\r\n                    const raw = JSON.parse(fs.readFileSync(rawPath, 'utf-8'));\r\n\r\n                    heavyItems.push({\r\n                        slug: slug,\r\n                        type: (raw.type as WikiType) || 'technical',\r\n                        category: raw.category || 'Uncategorized',\r\n                        title: raw.title || slug,\r\n                        tags: [],\r\n                        data: {}, // No light data available\r\n                        heavy: heavyData\r\n                    });\r\n                } catch { }\r\n            }\r\n        }\r\n    });\r\n    return heavyItems;\r\n};\r\n\r\n// Helper: Clean Mixed English/Localized Titles\r\nconst cleanLocalizedTitle = (text: string, lang: LangType): string => {\r\n    if (lang === 'EN') return text;\r\n\r\n    // Pattern 1: \"English (Localized)\" -> Keep Localized\r\n    // Pattern 2: \"Localized (English)\" -> Keep Localized\r\n\r\n    // Check if text has parentheses\r\n    const match = text.match(/^(.*?)\\s*\\((.*?)\\)$/);\r\n    if (match) {\r\n        const part1 = match[1];\r\n        const part2 = match[2];\r\n\r\n        // Heuristic: If one part has non-ASCII (likely localized) and the other is ASCII (English)\r\n        const isPart1ASCII = /^[\\x00-\\x7F]*$/.test(part1);\r\n        const isPart2ASCII = /^[\\x00-\\x7F]*$/.test(part2);\r\n\r\n        if (!isPart1ASCII && isPart2ASCII) return part1.trim(); // \"Localized (English)\" -> \"Localized\"\r\n        if (isPart1ASCII && !isPart2ASCII) return part2.trim(); // \"English (Localized)\" -> \"Localized\"\r\n    }\r\n\r\n    return text;\r\n};\r\n\r\nexport const getWikiData = (lang: LangType) => {\r\n    // 1. Glossary\r\n    const glossary = (glossaryMap[lang] as unknown[] || glossaryEn).map((item: unknown) => {\r\n        const i = item as { id: string; category: string; term: string; seo_keywords?: string[] };\r\n        return {\r\n            slug: i.id,\r\n            type: 'glossary' as WikiType,\r\n            category: cleanLocalizedTitle(i.category, lang),\r\n            title: cleanLocalizedTitle(i.term, lang),\r\n            tags: i.seo_keywords || [],\r\n            data: i,\r\n            heavy: loadHeavyData(i.id, lang)\r\n        };\r\n    });\r\n\r\n    // 2. Technical\r\n    const techEn = technicalEn;\r\n    // Fallback to EN if target lang file is missing, but map exists\r\n    const techTarget = technicalMap[lang] || technicalEn;\r\n\r\n    const technical: WikiItem[] = [];\r\n    techEn.forEach((cat: { category: string; indicators: { name: string; seo_keywords?: string[] }[] }, catIdx: number) => {\r\n        cat.indicators.forEach((ind: { name: string; seo_keywords?: string[] }, indIdx: number) => {\r\n            // Safely access target category and indicator\r\n            const targetCat = (techTarget[catIdx] || cat) as { category: string; indicators: { name: string; seo_keywords?: string[] }[] };\r\n            const targetInd = targetCat?.indicators?.[indIdx] as { name: string; seo_keywords?: string[] } | undefined;\r\n            const finalInd = targetInd || ind;\r\n\r\n            if (finalInd) {\r\n                // Use English Name for Slug (Canonical)\r\n                const slug = slugify(ind.name);\r\n                const rawTitle = finalInd.name;\r\n                const rawCategory = targetCat?.category || cat.category;\r\n\r\n                technical.push({\r\n                    slug: slug,\r\n                    type: 'technical' as WikiType,\r\n                    category: cleanLocalizedTitle(rawCategory, lang),\r\n                    title: cleanLocalizedTitle(rawTitle, lang),\r\n                    tags: finalInd.seo_keywords || [],\r\n                    data: finalInd,\r\n                    heavy: loadHeavyData(slug, lang)\r\n                });\r\n            }\r\n        });\r\n    });\r\n\r\n    // 3. Maxims\r\n    const maxEn = maximsEn;\r\n    const maxTarget = maximsMap[lang] as { category: string; quotes: any[] }[] || maximsEn;\r\n\r\n    const maxims: WikiItem[] = [];\r\n    maxEn.forEach((cat: { category: string; quotes: { id: string; text: string; meaning?: string; attribution?: string; seo_keywords?: string[] }[] }, catIdx: number) => {\r\n        cat.quotes.forEach((quote: { id: string; text: string; meaning?: string; attribution?: string; seo_keywords?: string[] }, quoteIdx: number) => {\r\n            const targetCat = (maxTarget[catIdx] || cat) as { category: string; quotes: { id: string; text: string; meaning?: string; attribution?: string; seo_keywords?: string[] }[] };\r\n            const targetQuote = targetCat?.quotes?.[quoteIdx];\r\n            const finalQuote = targetQuote || quote;\r\n\r\n            if (finalQuote) {\r\n                // For Maxims:\r\n                // If EN: Title = text (\"The trend is your friend\")\r\n                // If Non-EN: Title = meaning (\"雜句漢譏ｯ菴逧・恚蜿欺") because 'text' is usually left in English even in localized files\r\n\r\n                let displayTitle = `\"${finalQuote.text}\"`;\r\n                if (lang !== 'EN' && finalQuote.meaning) {\r\n                    // Check if meaning is different from text (i.e. it is actually translated)\r\n                    // In maxims-cn.json: text is English, meaning is Chinese.\r\n                    displayTitle = `\"${finalQuote.meaning}\"`;\r\n                }\r\n\r\n                maxims.push({\r\n                    slug: quote.id,\r\n                    type: 'maxim' as WikiType,\r\n                    category: cleanLocalizedTitle(targetCat?.category || cat.category, lang),\r\n                    title: displayTitle,\r\n                    tags: [finalQuote.attribution || ''],\r\n                    data: finalQuote,\r\n                    heavy: loadHeavyData(quote.id, lang)\r\n                });\r\n            }\r\n        });\r\n    });\r\n\r\n    // 4. Merge Heavy-Only Items (that are NOT in the lists above)\r\n    const existingSlugs = new Set([...glossary, ...technical, ...maxims].map(i => i.slug));\r\n    const heavyOnly = getHeavyOnlyItems(lang).filter(i => !existingSlugs.has(i.slug));\r\n\r\n    return [...glossary, ...technical, ...maxims, ...heavyOnly];\r\n};\r\n\r\nexport const getWikiItem = (slug: string, lang: LangType): WikiItem | undefined => {\r\n    const all = getWikiData(lang);\r\n    return all.find(item => item.slug === slug);\r\n};\r\n\r\nexport const getAllSlugs = () => {\r\n    return getWikiData('EN').map(item => item.slug);\r\n};\r\n","usedDeprecatedRules":[]}]
